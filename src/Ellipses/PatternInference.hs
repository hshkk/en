module Ellipses.PatternInference (
    cphi, 
    foldOverK, zipWithK
) where

import Data.Bifunctor (bimap)
import Data.List (transpose)

import Ellipses.AntiUnification
import Ellipses.Syntax
import Ellipses.SyntaxPatterns

-- Maps a given φ to a list of list slices, then collapses it into a single expression.
phifold :: ([Exp] -> Exp) -> Phi -> [Slice] -> Exp
phifold f phi vss = f $ foldl EApp phi . map EVal <$> (transpose . cut) vss
    where cut xss = map (take . minimum $ map length xss) xss

foldOverK :: Bin -> Phi -> [Slice] -> Exp
foldOverK op = phifold (foldl1 $ EBin op)

zipWithK :: Phi ->[Slice] -> Exp
zipWithK = phifold EList

-- Φ anti-unifies over a list of expressions, generating an inference of a function φ and slices ς* generated by ς.
cphi :: [Exp] -> (Phi, [ABSlice])
cphi exps = let au = antiunify exps in bimap (phi (snd au)) (reverse . map (sigma . fst)) au
-- (The original list slice order is initially reversed, hence the call above.)

-- φ describes a pattern able to  generate all elements of a list/fold expression.
phi :: [Sub] -> Exp -> Phi
phi [] e = e
phi ((_, EVar x):vs) e = phi vs (EAbs x e)
phi _ _ = error "An non-variable was declared as a substitution marker."

-- ς takes a list of expressions a substitution was defined for and constructs a list slice using the first two expressions in the list. 
-- (TODO: This behavior could be incorrect!)
sigma :: [Exp] -> ABSlice
sigma ((EExp (EEVar x n)):(EExp (EEVar x' n')):_) | x == x' = (n, n', x)
sigma (e1:e2:_) = (e1, e2, "_")
sigma _ = error "Insufficient information was provided to construct a list slice."