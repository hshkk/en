module Ellipses.PatternInference (cphi, slice) where

import Data.Bifunctor (bimap)

import Ellipses.AntiUnification
import Ellipses.Syntax

-- A tuple of two arithmetic expressions and a variable binded to a list.
type Slice = (Exp, Exp, EVar)
-- A tuple of a function (φ) and inferred list slices.
type Inference = (Exp, [Slice])

-- Φ anti-unifies over a list of expressions, generating an inference of φ and slices generated by Σ.
cphi :: Exps -> Inference
cphi exps = let au = antiunify exps in bimap (phi (snd au)) (reverse . map (sigma . fst)) au
-- (The original list slice order is initially reversed, hence the call above.)

-- φ describes a pattern able to  generate all elements of a list/fold expression.
phi :: Subs -> Exp -> Exp
phi [] e = e
phi ((_, EVar x):vs) e = phi vs (EAbs x e)
phi _ _ = error "An non-variable was declared as a substitution marker."

-- ς takes a list of expressions a substitution was defined for and constructs a list slice using the first two ellipsis variables in the list. 
-- (TODO: This behavior could be incorrect!)
sigma :: Exps -> Slice
sigma ((EExp (EEVar x n)):(EExp (EEVar x' n')):_) | x == x' = (n, n', x)
sigma _ = error "Insufficient information was provided to construct a list slice."

slice :: Int -> Int -> [a] -> [a]
slice a b | all (> 0) [a, b] = if a > b then reverse . slice' b a else slice' a b
    where slice' a b = take (b - a + 1) . drop (a - 1)
slice _ _ = error "a >= 1, b >= 1 must hold for a list slice (a, b, x)."