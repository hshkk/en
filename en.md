## Documentation of ellipsis expression evaluation

*Previously updated: 26/3/25*

---

In its current implementation, ellipsis expressions refer to
either lists (`[ẍ{e}, ..., ẍ{e}]`) or folds over binary operations (`e 𝜔 ... 𝜔 e`).
- `e` refers to an expression.
- `ẍ` refers to a list. Currently, normal variables and ellipsis variables are binded in the same way.
- `ẍ{e}` is an indexing operation. The most direct translation is `ẍ !! (k - 1)` where `k` is the integer yielded from evaluating `e`. 
    - So-called "index variables" can be used to denote the length of the list. Throughout this document, `n` is employed as an index variable.
    - Moreover, the braces may be omitted if the index expression is a single character and shares no letters with the referenced list. In other words, `xn` is a syntactic sugar for `x{n}`.
- `𝜔` refers to a built-in binary operation, like addition.

Please note that the evaluation process of list/fold expressions is identical until the terminal step.

### Anti-unification

The first step of evaluation is to determine the parts that differ between two expressions `e1` and `e2`, and replace them with variables, generating an expression `e`. This process is known as *anti-unification*.

In anti-unification, two substitutions `𝜎1` and `𝜎2` are generated in addition to `e` such that `𝜎1(e) = e1` and `𝜎2(e) = e2`, where `e` is minimally general in the sense that for every generalization `e'` generated from `e1` and `e2`, there exists a substitution such that `𝜎'(e') = e`. 

(The anti-unification algorithm used in this project is adapted from Figure 2 of "A function reconstruction of anti-unification", Østvold (2004).)

In addition to generating substitutions (which is the primary topic of Østvold's paper) a function `φ` is constructed such that `φ Σ1 = e1` and `φ Σ2 = e2`. (`Σ` also refers to a substitution, but its representation is a parameter rather than the aforementioned substitutionary function `𝜎`.) In other words, `φ` is the pattern that can generate every element in the ellipsis expression, including those that are unelided.

#### Examples

```
map f [x1, ..., xn] = [f x1, ..., f xn]

φ = \v1 -> f v1
```

```
neighbors [x1, ..., xn] = [(x1, x2), ..., (x{n - 1}, xn)]

φ = \v1 -> \v2 -> (v1, v2)
```

One other remark to make is that some types of expressions cannot be anti-unified. For example, while `φ = \v1 -> v1` for the following expression, it is unclear what the ellipsis elides, if anything.

```
[x, ..., y]
```

As a result, the current implementation only allows anti-unification over mismatched function applications (which includes constructors), fixpoint operations,  binary operations, and ellipsis variables. And even then, for a given part of an expression, the referenced list (for anti-unification over ellipsis variables) and the constituent operation (for anti-unification over binary operation expressions) may not differ. Respectively, expressions like `[x1, ..., yn]` and `[x1 + 1, ..., xn - 1]` are invalid, as the elision is ambiguous. 

However, please note that expressions like `zip [x1, ..., xn] [y1, ..., ym] = [(x1, y1), ..., (xn, ym)]` are valid, since the two lists `x` and `y` are referenced in the same part of each constituent expression. However, a related (and critical) question is what the semantics of `(xn, ym)` should be when `n ≠ m`. 

Currently, the list length ends up being the smallest of `n` and `m` due to the `zipWith`-like implementation of element generation explained later in this document.

```haskell
zip [x1, ..., xn] [y1, ..., ym] = [(x1, y1), ..., (xn, ym)]

> zip [1, 2, 3] [4, 5, 6]
[(1, 4), (2, 5), (3, 6)]

> zip [1, 2, 3] [4, 5]
[(1, 4), (2, 5)]

> zip [1, 2] [4, 5, 6]
[(1, 4), (2, 5)]
```

### Pattern inference

The second step is to determine what substitutions should be made. This determination requires identification of the parts of the list(s) that are needed. These parts are defined by a list `ς*` of a/b-slices `ς = (a, b, ẍ) = [ẍa, ..., ẍb]` for the list `ẍ = [ẍ1, ..., ẍn]` and `1 ≤ a ≤ b ≤ n`. If `a > b`, the order of elements is reversed. Slices can be constructed from the substitutions generated by Østvold's algorithm, defined by the type synonym `ABSlice` in the `Ellipses.Syntax` module.

#### Examples

```
map f [x1, ..., xn] = [f x1, ..., f xn]

ς* = [(1, n, x)]
```

```
neighbors [x1, ..., xn] = [(x1, x2), ..., (x{n - 1}, xn)]

ς* = [(1, n - 1, x), (2, n, x)]
```

```
zip [x1, ..., xn] [y1, ..., ym] = [(x1, y1), ..., (xn, ym)]

ς* = [(1, n, x), (1, m, y)]
```

An inference is represented as a tuple `Φ = (φ, ς*)`.

### Element generation

#### `φfold`

The terminal step of the ellipsis expression evaluation process is to generate the elided elements. We can fold `φ` over the inferred a/b slices `ς*` (which are first converted to the sublists they refer to) to yield a list containing every element, as outlined in the `Ellipses.PatternInference` module (albeit with different variable names). The resultant list can then be additionally processed to transform it into a single expression.

Type synonyms are employed to further clarify what `φfold` does; the original types are included below.

```haskell
type Phi = Exp
type Slice = [Val]

φfold :: ([Exp] -> Exp) -> Phi -> [Slice] -> Exp
φfold f φ ς* = f $ foldl EApp φ . map EVal <$> (transpose . cut) ς*
    where cut ς* = map (take . minimum $ map length ς*) ς*
```

`φfold` is admittedly probably best understood via an example. Please consider the following expression, which generates a list by adding consecutive elements together.

```haskell
let x = [1, 2, 3, 4] in [x1 + x2, ..., x{n - 1} + xn]
```

From anti-unification and pattern inference, the following inference is produced.

```
Φ = (φ, ς*)

φ = \v1 -> \v2 -> v1 + v2
ς* = [ς1, ς2]
ς1 = (1, n - 1, x) ~> [1, 2, 3]
ς2 = (2, n, x)     ~> [2, 3, 4]
```

`φfold` proceeds as follows, with some constructor names elided for readability. (Notably excluding `EList` and `VList`, as their types differ from Haskell lists of values/expressions.) Please note that the `EList` constructor is employed as an argument to `φfold` to yield a list in the end, since `[x1 + x2, ..., x{n - 1} + xn]` is a list expression.

```haskell
-- At the current point of evaluation, f = EList, φ = \v1 -> \v2 -> v1 + v2, and ς* is made up of list slices ς1 and ς2 which contain values.
> φfold EList φ ς*

-- cut intends to replicate the behavior of zipWith by cutting the length of every slice with respect to the shortest slice. Since every slice is the same length in this example, nothing happens.
cut ς* ~> [[1, 2, 3], [2, 3, 4]] :: [Slice]

-- ς* is then rearranged so that each constituent list is representative of the arguments passed together to φ.  
(transpose . cut) ς* ~> [[1, 2], [2, 3], [3, 4]] :: [Slice]

-- Each value is converted to a literal expression, which is required for applying φ. fmap makes this a little nicer!
map EVal <$> (transpose . cut) ς* ~> [[1, 2], [2, 3], [3, 4]] :: [[Exp]]

-- φ is then folded over each constituent list, generating the complete list of elements, including those elided by an ellipsis.
foldl EApp φ . map EVal <$> (transpose . cut) ς* ~> [φ 1 2, φ 2 3, φ 3 4] :: [Exp]

-- The list of expressions is then converted to a single expression representing a list. The ellipsis expression evaluation process is complete, and the resultant expression may now be fully evaluated in the usual manner.
f $ foldl EApp φ . map EVal <$> (transpose . cut) ς* ~> EList [φ 1 2, φ 2 3, φ 3 4] :: Exp

... ~> VList [3, 5, 7] :: Val
```

Due to this somewhat verbose explanation, `φfold`'s implementation could probably be made simpler.

#### `zipWithK`

The evaluation behavior outlined here is `zipWithK`, which is equivalent to `φfold` with `EList` as the first argument. (`k` denotes the number of list slices to fold `φ` over.)

```haskell
zipWithK :: Exp -> [Slice] -> Exp
zipWithK = φfold EList
```

Please note that `zipWith1` is equivalent to Haskell's `map`, and `zipWith2` is equivalent to Haskell's `zipWith`.

(As a side note, η-reduction removes the need to write `φ` and `ς*` as parameters, making the definition of `zipWithK` very succinct!)

#### `foldOverK`

The implementation of fold expressions is strikingly similar, but instead of generating an expression representing a list, we generate an expression representing a chain of binary operations.

```haskell
foldOverK :: Bin -> Exp -> [Slice] -> Exp
foldOverK 𝜔 = φfold (foldl1 $ EBin 𝜔)
```

Please note that `foldOverK` is equivalent to Haskell's `foldl1` with a binary operator as its first argument, as implied by the first argument to `φfold`. As a result, `k` plays very little role in understanding `foldOverK`'s semantics, but one translation of the function's name could be "*fold* `𝜔` *over* `k` list slices".